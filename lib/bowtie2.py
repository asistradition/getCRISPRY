from __future__ import print_function

from .degenerate_tools import fix_seq_object

import tempfile
import os
import subprocess

from Bio import SeqIO
from Bio.Seq import Seq
from Bio.Alphabet import generic_dna

SAMTOOLS_MAP = {"FLAG": 1,
                "RNAME": 2,
                "POS": 3,
                "SEQ": 9}

BOWTIE_SEED_LENGTH = 10
BOWTIE_SEED_MISMATCH = 1



def bowtie_make_index(dir_path, genome):
    """
    Makes a bowtie index in a specified directory from a FASTA file

    :param dir_path: str
        Path to target directory
    :param genome: str
        Path to sequence FASTA file

    :return out_db_path:
        Path to the bowtie index that can be passed to bowtie
    """

    if not os.path.isfile(genome):
        raise FileNotFoundError

    if not os.path.isdir(dir_path):
        raise NotADirectoryError

    _, gen_name = os.path.split(genome)

    out_db_path = os.path.join(dir_path, gen_name.split(".")[0])
    build_cmd = ["bowtie2-build", "-f", genome, out_db_path]
    proc = subprocess.run(build_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    proc.check_returncode()

    return out_db_path


def bowtie_get_hits(query, db_path, cores=1):
    """
    Align a query sequence to a target reference genome database and parse the resulting SAM file.

    :param query: [SeqRecord]
        A list of SeqRecord objects which should be aligned to the reference genome
    :param db_path: str
        A path to the reference genome database. Passed to bowtie2.
    :param cores: int
        Number of CPU cores to run. Passed to bowtie2.

    :return: {query_seq: [(mapped_seq, chr_name, position, strand, mismatch#)] : dict{str:[(Bio.Seq, str, int, str, int)]}
        Returns a dict keyed by query sequence of a list of hit tuples that consist of the mapped sequence, the
        chromosome of the mapped location, the position of the mapped location, the strand, and the number of mismatches
        to the query sequence
    """
    try:
        sam = _bowtie_align(query, db_path, cores=cores)
        hits = _bowtie_sam_parse(sam)
    except:
        raise
    finally:
        try:
            os.remove(sam)
        except FileNotFoundError:
            pass

    return hits


def bowtie_check_index(db_path):
    """
    Check to make sure that the bowtie index exists. Raises a FileNotFoundError if there is any problem.

    :param db_path: str
        A path to the reference genome database. Passed to bowtie-inspect.
    :return: bool
        Returns TRUE if no error
    """
    try:
        inspect_command = ["bowtie2-inspect", "-s", db_path]
        proc = subprocess.run(inspect_command, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL)
        proc.check_returncode()
    except subprocess.CalledProcessError as err:
        raise FileNotFoundError("Unable to inspect bowtie index")

    return True


def _bowtie_align(query, db_path, sam_path=None, cores=1):
    """
    Runs bowtie2 with a list of sequencs as queries against a target reference genome database.

    :param query: [SeqRecord]
        A list of SeqRecord objects
    :param db_path: str
        A path to the reference genome database. Passed to bowtie2.
    :param sam_path: str
        A path to the output SAM file. If None (or not set), a tempfile will be created
    :param cores: int
        Number of CPU cores to run. Passed to bowtie2.

    :return: str
        Returns a path to the output SAM file (unchanged, unless the param sam_path was not set)
    """
    try:

        #Create a temporary file to hold the queries
        _hand, fasta_name = tempfile.mkstemp()


        #Create a temporary file to hold the SAM output, if a path was not provided
        if sam_path is None:
            _, sam_path = tempfile.mkstemp()

        #Write the queries out as a FASTA file
        with open(_hand, mode="w") as temp_fh:
            SeqIO.write(query, temp_fh, format="fasta")

        #Run bowtie 2 and put the output into /dev/null. Check the return code.
        bowtie_cmd = ["bowtie2", "-f", fasta_name, "-x", db_path, "-S", sam_path, "-a", "-L", str(BOWTIE_SEED_LENGTH),
                      "-N", str(BOWTIE_SEED_MISMATCH), "--mp", "1,1", "--threads", str(cores)]
        proc = subprocess.run(bowtie_cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        proc.check_returncode()
    except:
        raise
    finally:
        #Clean up the temporary FASTA file
        os.remove(fasta_name)

    return sam_path


def _bowtie_sam_parse(sam_path, remove=False):
    """
    Takes a path to a sam file produced by bowtie and parses it into a dict keyed by query of hits

    :param sam_path: str
        Path to SAM file generated by bowtie
    :param remove: bool
        Remove the SAM file after parsing

    :return {query_seq: [(mapped_seq, chr_name, position, strand, mismatch#)] : dict{str:[(Bio.Seq, str, int, str, int)]}
        Returns a dict keyed by query sequence of a list of hit tuples that consist of the mapped sequence, the
        chromosome of the mapped location, the position of the mapped location, the strand, and the number of mismatches
        to the query sequence
    """
    sequences = {}
    try:
        with open(sam_path, mode="rU") as sam_fh:
            for line in sam_fh:
                try:
                    query_seq, map_seq, rname, pos, strand, nm = _parse_sam_line(line)
                except ValueError:
                    continue

                try:
                    sequences[str(query_seq)].append((map_seq, rname, pos, strand, nm))
                except KeyError:
                    sequences[str(query_seq)] = [(map_seq, rname, pos, strand, nm)]
    except:
        raise
    finally:
        if remove:
            os.remove(sam_path)

    return sequences


def _parse_sam_line(line_str):
    if line_str[0] is "@":
        raise ValueError

    li_arr = line_str.strip().split()

    opt_flags = {}

    for val in li_arr:

        try:
            if val[2] is ":":
                _v_arr = val.split(":")
                opt_flags[_v_arr[0]] = _v_arr[-1]
        except IndexError:
            pass

    query_seq = Seq(li_arr[SAMTOOLS_MAP["SEQ"]])
    rname = li_arr[SAMTOOLS_MAP["RNAME"]]
    pos = int(li_arr[SAMTOOLS_MAP["POS"]])
    _flag = int(li_arr[SAMTOOLS_MAP["FLAG"]])

    try:
        nm = int(opt_flags["NM"])
    except KeyError:
        nm = 0

    try:
        map_seq = Seq(_rewrite_to_reference(query_seq, opt_flags["MD"]), alphabet=generic_dna)
    except KeyError:
        map_seq = query_seq

    if (_flag % 256) == 16:
        query_seq = query_seq.reverse_complement()
        map_seq = map_seq.reverse_complement()
        strand = "-"
    else:
        strand = "+"

    return query_seq, map_seq, rname, pos, strand, nm


def _rewrite_to_reference(seq_str, mm):
    seq_str = fix_seq_object(seq_str, make_type="str")

    _tmp_mm = ""
    pointy = 0
    srr = list(seq_str)

    for i in range(len(mm)):
        if mm[i].isalpha():
            if _tmp_mm is not "":
                pointy += int(_tmp_mm)
                _tmp_mm = ""
            srr[pointy] = mm[i]
            pointy += 1
        else:
            _tmp_mm += mm[i]

    return "".join(srr)
